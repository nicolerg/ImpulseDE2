---
title: "QC ImpulseDE2"
author: "Nicole Gay"
date: "6/2/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/oak/stanford/groups/smontgom/nicolerg/src/MOTRPAC/ImpulseDE2/R/')
library(compiler)
library(Biobase)
library(BiocParallel)
library(circlize)
library(ComplexHeatmap)
library(cowplot)
library(DESeq2)
library(ggplot2)
library(grDevices)
library(knitr)
library(Matrix)
library(methods)
library(stats)
library(SummarizedExperiment)
library(utils)
library(olsrr)
library(data.table)
```

## Source my edited version of ImpulseDE2
```{r source functions}
for(f in list.files()){
  print(f)
  source(f)
}
```

## Starting point - simulated data 
```{r simulate data}
# case-only with batch effects
lsSimulatedData <- simulateDataSetImpulseDE2(
  vecTimePointsA   = rep(seq(1,8),4),
  vecTimePointsB   = NULL,
  vecBatchesA      = c(rep(1,15), rep(2,17)),
  vecBatchesB      = NULL,
  scaNConst        = 30,
  scaNImp          = 50,
  scaNLin          = 10,
  scaNSig          = 30,
  scaMuBatchEffect = 3,
  scaSDBatchEffect = 0.2,
  dirOutSimulation = NULL)

```

```{r adjust df}
dfAnnotation = lsSimulatedData$dfAnnotation
matCounts = lsSimulatedData$matObservedCounts
dim(matCounts)
dfAnnotation
# call "Batch" something else
colnames(dfAnnotation)[colnames(dfAnnotation) == 'Batch'] = 'sample_batch'
# add sex covariate
dfAnnotation$sex = sample(c('male','female'), replace=TRUE, size=nrow(dfAnnotation))
# add continuous covariate
dfAnnotation$num_var = rnorm(nrow(dfAnnotation))
head(dfAnnotation)
table(dfAnnotation$Time, dfAnnotation$sample_batch)
```

## Scenario 1: perfect confounding
```{r add confounder, eval=F}
dfAnnotation$var1 = ifelse(dfAnnotation$sex == 'female', 5, 10)
```

## Scenario 2: collinearity
```{r add collinear cov, eval=F}
f = rnorm(nrow(dfAnnotation[dfAnnotation$sex =='female',]), 5, 0.5)
m = rnorm(nrow(dfAnnotation[dfAnnotation$sex == 'male',]), 10, 1)
dfAnnotation$var1[dfAnnotation$sex == 'female'] = f
dfAnnotation$var1[dfAnnotation$sex == 'male'] = m
```

```{r set params}
matCountData = matCounts
boolCaseCtrl = FALSE
vecCovFactor = c('sex')
vecCovContinuous = c('num_var')
scaNProc = 1
boolVerbose = TRUE
boolBeta2 = TRUE
scaQThres = NULL
vecSizeFactorsExternal = NULL
vecDispersionsExternal = NULL
boolIdentifyTransients = TRUE 
boolVerbose = TRUE
MAXIT = 1000
```

## Check to see if covariates affect dispersions
```{r deseq dispersions, eval=F}
dds1 <- DESeqDataSetFromMatrix(
    countData = matCountData,
    colData = dfAnnotation,
    design = ~ Time)
dds1 <- estimateSizeFactors(dds1)
dds1 <- estimateDispersions(dds1)

dds2 <- DESeqDataSetFromMatrix(
    countData = matCountData,
    colData = dfAnnotation,
    design = ~ 1)
dds2 <- estimateSizeFactors(dds2)
dds2 <- estimateDispersions(dds2)

dispersions(dds1) == dispersions(dds2)
```

# Walk through main function, step by step 
```{r process data, eval=F}
# 1. Process input data
# Extract count matrix if handed SummarizedExperiment
if (class(matCountData) == "SummarizedExperiment"){ 
    matCountData <- assay(matCountData)
}
lsProcessedData <- processData(
    dfAnnotation = dfAnnotation, 
    matCountData = matCountData, 
    boolCaseCtrl = boolCaseCtrl, 
    boolBeta2 = boolBeta2,
    vecCovFactor = vecCovFactor, 
    vecCovContinuous = vecCovContinuous,
    vecDispersionsExternal = vecDispersionsExternal, 
    vecSizeFactorsExternal = vecSizeFactorsExternal)

matCountDataProc <- lsProcessedData$matCountDataProc
dfDESeqAnnotationProc <- lsProcessedData$dfDESeqAnnotationProc
lsdfCovProc <- lsProcessedData$lsdfCovProc
vecSizeFactorsExternalProc <- 
    lsProcessedData$vecSizeFactorsExternalProc
vecDispersionsExternalProc <- 
    lsProcessedData$vecDispersionsExternalProc
```

```{r check processed data, eval=F}
# look at a few things 
head(lsProcessedData$dfDESeqAnnotationProc)
names(head(lsProcessedData$lsdfCovProc)) # lsdfCovProc is a new addition
head(lsProcessedData$lsdfCovProc$case)
head(lsProcessedData$lsdfCovProc$control)
```

```{r DESeq2, eval=F}
# 2. Run DESeq2 Use dispersion factors from DESeq2 if
if (is.null(vecDispersionsExternal)) {
    vecDispersions <- runDESeq2(
        dfAnnotationProc = dfDESeqAnnotationProc, 
        matCountDataProc = matCountDataProc, 
        boolCaseCtrl = boolCaseCtrl, 
        vecCovFactor = vecCovFactor,
        vecCovContinuous = vecCovContinuous)
} else {
    # Use externally provided dispersions and reorder
    vecDispersions <- vecDispersionsExternalProc
}

# 3. Compute size factors
vecSizeFactors <- computeNormConst(
    matCountDataProc = matCountDataProc, 
    vecSizeFactorsExternal = vecSizeFactorsExternalProc)
```

```{r create instance, eval=F}
# 4. Create instance of ImpulseDE2Object Create ImpulseDE2 object
objectImpulseDE2 <- new(
    "ImpulseDE2Object", 
    dfImpulseDE2Results = NULL, 
    vecDEGenes = NULL, 
    lsModelFits = NULL, 
    matCountDataProc = matCountDataProc, 
    vecAllIDs = rownames(matCountData), 
    dfDESeqAnnotationProc = dfDESeqAnnotationProc, 
    lsdfCovProc = lsdfCovProc,
    vecSizeFactors = vecSizeFactors, 
    vecDispersions = vecDispersions, 
    boolCaseCtrl = boolCaseCtrl, 
    boolBeta2 = boolBeta2,
    vecCovFactor = vecCovFactor, 
    vecCovContinuous = vecCovContinuous,
    scaNProc = scaNProc, 
    scaQThres = scaQThres, 
    strReport = strReport)
```

```{r check new things, eval=F}
names(get_lsdfCovProc(objectImpulseDE2))
head(get_lsdfCovProc(objectImpulseDE2)$case)
head(get_dfDESeqAnnotationProc(objectImpulseDE2))
get_vecCovContinuous(objectImpulseDE2)
get_vecCovFactor(objectImpulseDE2)
```

```{r fit null and alt for each gene, eval=F}
# 5. Fit null and alternative model to each gene
objectImpulseDE2 <- fitModels(
    objectImpulseDE2 = objectImpulseDE2, 
    boolCaseCtrl = boolCaseCtrl,
    boolBeta2 = boolBeta2,
    MAXIT = MAXIT)
```

```{r fit sigmoid, eval=F}
# 6. Fit sigmoid model to case condition if desired
if (boolIdentifyTransients) {
    objectImpulseDE2 <- fitSigmoidModels(
        objectImpulseDE2 = objectImpulseDE2, 
        strCondition = "case",
        MAXIT = MAXIT)
}
```

```{r DEA, eval=F}
# 7. Differentially expression analysis based on model fits
objectImpulseDE2 <- runDEAnalysis(
    objectImpulseDE2 = objectImpulseDE2, 
    boolCaseCtrl = get_boolCaseCtrl(obj=objectImpulseDE2),
    boolIdentifyTransients = boolIdentifyTransients,
    boolBeta2 = boolBeta2)

if (!is.null(scaQThres)) {
    vecDEGenes <- as.vector(objectImpulseDE2$dfImpulseDE2Results[
        as.numeric(objectImpulseDE2$dfImpulseDE2Results$padj) <= 
            scaQThres, "Gene"])
    strMessage <- paste0("Found ", length(vecDEGenes), " DE genes", 
                         " at a FDR corrected p-value cut off of ", 
                         scaQThres, ".")
    if (boolVerbose) { message(strMessage) }
    objectImpulseDE2 <- append_strReport(obj = objectImpulseDE2,
                                         s = strMessage)
} else {
    vecDEGenes <- NULL
}
objectImpulseDE2 <- set_vecDEGenes(obj=objectImpulseDE2,
                                   element=vecDEGenes)
```

```{r now do it all it one step}
objectImpulseDE3 = runImpulseDE2(
    matCountData = matCountData, 
    dfAnnotation = dfAnnotation, 
    boolCaseCtrl = boolCaseCtrl, 
    boolBeta2 = boolBeta2,
    vecCovFactor = vecCovFactor, 
    vecCovContinuous = vecCovContinuous,
    scaNProc = 1, 
    scaQThres = NULL, 
    boolIdentifyTransients = TRUE, 
    boolVerbose = TRUE,
    MAXIT = 1000) 
```

```{r look at output}
names(objectImpulseDE3)
dfres = objectImpulseDE3$dfImpulseDE2Results
head(dfres)
table(dfres$isTransient)
table(dfres$isMonotonous)
table(dfres$padj < 0.05)
dtres = data.table(dfres)
dtres[isTransient==TRUE]
dtres[isMonotonous==TRUE & padj < 0.05] # why are these DE if they're monotonous?

# get model fits
mod = get_lsModelFits(obj=objectImpulseDE3)$case$gene1$lsImpulseFit$vecImpulseParam


modelfits = computeModelFits(objectImpulseDE3)
names(modelfits)
modelfits$case["gene63",]
modelfits$sample["gene63",]

obj = objectImpulseDE3
matBatchFactors <- model.matrix(~., data=get_lsdfCovProc(obj=obj)[["case"]])[,-1]
vecThetaCovar <- get_lsModelFits(obj=obj)[["case"]][["gene1"]]$lsImpulseFit$vecCorrectionFactors
vecBatchFactors <- t(exp(matBatchFactors %*% vecThetaCovar))
```